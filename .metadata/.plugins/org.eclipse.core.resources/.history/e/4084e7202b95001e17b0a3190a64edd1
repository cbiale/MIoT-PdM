/*
 * port.c
 *
 *  Archivo que implementa las funciones que abstraen a las bibliotecas de la HAL.
 *  Permite portabilidad.
 *
 *  Created on: Dec 3, 2023
 *      Author: cbiale
 */

#include "port.h"

/* --------------------------------- Constantes --------------------------------- */

// constantes para manejo de leds
#define LD1_Pin GPIO_PIN_0
#define LD1_GPIO_Port GPIOB
#define LD2_Pin GPIO_PIN_7
#define LD2_GPIO_Port GPIOB
#define LD3_Pin GPIO_PIN_14
#define LD3_GPIO_Port GPIOB

// Variables privadas que manejan perifericos
static I2C_HandleTypeDef hi2c1; // manejador de I2C


/* ---------------------------------- Funciones --------------------------------- */

// Función que detiene la ejecución del programa en caso de error.
void manejar_errores(void) {
	HAL_GPIO_WritePin(LD1_GPIO_Port, LD1_Pin, GPIO_PIN_SET);
	HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_SET);
	HAL_GPIO_WritePin(LD3_GPIO_Port, LD3_Pin, GPIO_PIN_SET);
	__disable_irq();
	while (1) {
	}
}

// Inicializa el módulo I2C.
void I2C_iniciar(void) {
	hi2c1.Instance = I2C1;
	hi2c1.Init.ClockSpeed = 100000;
	hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
	hi2c1.Init.OwnAddress1 = 0;
	hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
	hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
	hi2c1.Init.OwnAddress2 = 0;
	hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
	hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
	if (HAL_I2C_Init(&hi2c1) != HAL_OK) {
		manejar_errores();
	}

	/** Configura el filtro analogico
	 */
	if (HAL_I2CEx_ConfigAnalogFilter(&hi2c1, I2C_ANALOGFILTER_ENABLE)
			!= HAL_OK) {
		manejar_errores();
	}

	/** Configura el filtro digital
	 */
	if (HAL_I2CEx_ConfigDigitalFilter(&hi2c1, 0) != HAL_OK) {
		manejar_errores();
	}
}

// Transmite un dato a través del bus I2C.
void I2C_transmitir(uint16_t direccion, uint8_t *dato, uint8_t tamano,
		uint8_t tiempo_espera) {
	if (HAL_I2C_Master_Transmit(&hi2c1, direccion << 1, dato, tamano,
			tiempo_espera) != HAL_OK) {
		manejar_errores();
	}
}

// Lee un dato a través del bus I2C.
void I2C_recibir(uint16_t direccion, uint8_t *dato, uint8_t tamano,
		uint8_t tiempo_espera) {
	if (HAL_I2C_Master_Receive(&hi2c1, direccion << 1, dato, tamano,
			tiempo_espera) != HAL_OK) {
		manejar_errores();
	}
}

// Espera durante un período de tiempo especificado en milisegundos
void esperar(uint32_t tiempo) {
	HAL_Delay(tiempo);
}


void esperar_ms (uint32_t microsegundos) {
	uint32_t clk_cycle_start = DWT->CYCCNT;
	microsegundos *= (HAL_RCC_GetHCLKFreq() / 1000000);
	while ((DWT->CYCCNT - clk_cycle_start) < microsegundos) {
	}
}


void Set_Pin_Output(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin) {
	GPIO_InitTypeDef gpio_estructura_inicio = { 0 };
	gpio_estructura_inicio.Pin = GPIO_Pin;
	gpio_estructura_inicio.Mode = GPIO_MODE_OUTPUT_PP;
	gpio_estructura_inicio.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOx, &gpio_estructura_inicio);
}

void Set_Pin_Input(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin) {
	GPIO_InitTypeDef gpio_estructura_inicio = { 0 };
	gpio_estructura_inicio.Pin = GPIO_Pin;
	gpio_estructura_inicio.Mode = GPIO_MODE_INPUT;
	gpio_estructura_inicio.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(GPIOx, &gpio_estructura_inicio);
}

// se debe ver forma de hacer generico
void escribir_pin (GPIO_TypeDef* puerto, uint16_t pin, GPIO_PinState estado) {
	HAL_GPIO_WritePin(puerto, pin, estado);
}

// se debe ver forma de hacer generico
GPIO_PinState leer_pin (GPIO_TypeDef* puerto, uint16_t pin) {
	return HAL_GPIO_ReadPin(puerto, pin);
}


/**
 * @brief Función que es parte del inicio para usar un dht22
 */
uint32_t DWT_Delay_Init(void) {
	// se deshabilita TRC
	CoreDebug->DEMCR &= ~CoreDebug_DEMCR_TRCENA_Msk; // ~0x01000000;
	// se habilita TRC
	CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk; // 0x01000000;

	// desabilita el clock cycle counter
	DWT->CTRL &= ~DWT_CTRL_CYCCNTENA_Msk; //~0x00000001;
	// habilita clock cycle counter
	DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk; //0x00000001;
	// resetea el valor del clock cycle counter
	DWT->CYCCNT = 0;

	__ASM
	volatile ("NOP");
	__ASM
	volatile ("NOP");
	__ASM
	volatile ("NOP");

	// controla si el clock cycle counter se ha iniciado
	if (DWT->CYCCNT) {
		return 0; // Si!!
	} else {
		return 1; // No iniciado
	}
}

