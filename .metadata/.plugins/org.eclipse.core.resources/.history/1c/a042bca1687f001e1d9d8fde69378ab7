/*
 * API_debounce.c
 *
 *  Created on: Nov 8, 2023
 *      Author: cbiale
 */
#include "API_debounce.h"

#define USER_Btn_Pin GPIO_PIN_13
#define USER_Btn_GPIO_Port GPIOC
#define LD1_Pin GPIO_PIN_0
#define LD1_GPIO_Port GPIOB

typedef enum
{
    BUTTON_UP,
    BUTTON_FALLING,
    BUTTON_DOWN,
    BUTTON_RISING
} debounceState_t;

/* El tiempo de anti-rebote debe ser de 40 ms con un retardo no bloqueante como los
 * implementados en la práctica 3.
 */
const uint32_t duracionRetardo = 40u;

debounceState_t estado;
delay_t retardo;

void debounceFSM_init() {
	estado = BUTTON_UP;
}

void debounceFSM_update() {
	switch (estado) {
	case BUTTON_UP:
		if (HAL_GPIO_ReadPin(USER_Btn_GPIO_Port, USER_Btn_Pin) == 0) {
			estado = BUTTON_FALLING;
			delayInit(&retardo, duracionRetardo);
			delayRead(&retardo);
		}
		break;
	case BUTTON_FALLING:
		if (delayRead(&retardo)) {
			if (HAL_GPIO_ReadPin(USER_Btn_GPIO_Port, USER_Btn_Pin) == 0) {
				estado = BUTTON_DOWN;
				buttonPressed();
			} else {
				estado = BUTTON_UP;
			}
		}
		break;
	case BUTTON_DOWN:
		if (HAL_GPIO_ReadPin(USER_Btn_GPIO_Port, USER_Btn_Pin) != 0) {
			estado = BUTTON_RISING;
			delayInit(&retardo, duracionRetardo);
			delayRead(&retardo);
		}
		break;
	case BUTTON_RISING:
		if (delayRead(&retardo)) {
			if (HAL_GPIO_ReadPin(USER_Btn_GPIO_Port, USER_Btn_Pin) != 0) {
				estado = BUTTON_UP;
				buttonReleassed();
			} else {
				estado = BUTTON_UP;
			}
		}
		break;
	default:
		break;
	}
}

/* La función readKey debe leer una variable interna del módulo y devolver true o false si la tecla fue presionada.  Si devuelve true, debe resetear (poner en false) el estado de la variable.*/
bool_t readKey() {
	return false;
}

void buttonPressed() {
	HAL_GPIO_WritePin(LD1_GPIO_Port, LD1_Pin, GPIO_PIN_SET);
}

void buttonReleassed() {
	HAL_GPIO_WritePin(LD1_GPIO_Port, LD1_Pin, GPIO_PIN_RESET);
}

